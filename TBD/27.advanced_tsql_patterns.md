---
# 27. Advanced T-SQL Patterns

**Objective:** Master advanced T-SQL techniques to write efficient, maintainable, and complex queries in MS SQL for real-world data engineering scenarios.

---

## 27.1 Common Table Expressions (CTEs)

- **Definition:** Temporary named result sets that can be referenced within a single query.
- **Uses:** Simplify complex queries, recursive queries, and improve readability.

**Example - Simple CTE:**
```sql
WITH CustomerCTE AS (
    SELECT CustomerID, FirstName, LastName
    FROM Sales.Customer
    WHERE IsActive = 1
)
SELECT * FROM CustomerCTE;
```

**Example - Recursive CTE:**
```sql
WITH OrgHierarchy AS (
    SELECT EmployeeID, ManagerID, Name, 0 AS Level
    FROM HumanResources.Employee
    WHERE ManagerID IS NULL
    UNION ALL
    SELECT e.EmployeeID, e.ManagerID, e.Name, h.Level + 1
    FROM HumanResources.Employee e
    INNER JOIN OrgHierarchy h ON e.ManagerID = h.EmployeeID
)
SELECT * FROM OrgHierarchy;
```

---

## 27.2 Window Functions

- Perform calculations across sets of rows related to the current row without collapsing the result set.
- Examples: `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `NTILE()`, `SUM() OVER()`, `AVG() OVER()`

**Example:**
```sql
SELECT CustomerID, OrderDate, TotalDue,
       ROW_NUMBER() OVER(PARTITION BY CustomerID ORDER BY OrderDate DESC) AS RowNum
FROM Sales.SalesOrderHeader;
```

**Use Cases:**
- Pagination
- Top-N per group
- Running totals
- Percentiles

---

## 27.3 APPLY Operator

- **CROSS APPLY:** Join each row with the results of a table-valued function or derived table.
- **OUTER APPLY:** Similar to LEFT JOIN, returns NULL if no match.

**Example - Top order per customer:**
```sql
SELECT c.CustomerID, c.Name, o.TopOrderDate
FROM dbo.Customers c
OUTER APPLY (
    SELECT TOP 1 OrderDate AS TopOrderDate
    FROM dbo.Orders o
    WHERE o.CustomerID = c.CustomerID
    ORDER BY OrderDate DESC
) o;
```

---

## 27.4 PIVOT and UNPIVOT

- Transform rows into columns (`PIVOT`) and columns into rows (`UNPIVOT`).

**Example - PIVOT:**
```sql
SELECT ProductID, [2018], [2019], [2020]
FROM (
    SELECT ProductID, YEAR(OrderDate) AS OrderYear, TotalDue
    FROM Sales.SalesOrderHeader
) src
PIVOT (
    SUM(TotalDue) FOR OrderYear IN ([2018], [2019], [2020])
) pvt;
```

**Example - UNPIVOT:**
```sql
SELECT ProductID, OrderYear, TotalDue
FROM (
    SELECT ProductID, [2018], [2019], [2020]
    FROM Sales.SalesSummary
) p
UNPIVOT (
    TotalDue FOR OrderYear IN ([2018], [2019], [2020])
) unpvt;
```

---

## 27.5 Advanced JOIN Patterns

- **Self-Joins:** Join a table to itself for comparisons.
- **Anti-Joins:** Find missing or unmatched records using `NOT EXISTS` or `LEFT JOIN ... WHERE IS NULL`.
- **Semi-Joins:** Find matching records using `EXISTS` without returning duplicates.

**Example - Anti-Join:**
```sql
SELECT c.CustomerID, c.Name
FROM dbo.Customers c
WHERE NOT EXISTS (
    SELECT 1 FROM dbo.Orders o
    WHERE o.CustomerID = c.CustomerID
);
```

---

## 27.6 Dynamic SQL

- Build and execute SQL statements dynamically at runtime.
- Useful for parameterized queries, flexible reporting, and automation.

**Example:**
```sql
DECLARE @SQL NVARCHAR(MAX);
DECLARE @Year INT = 2024;

SET @SQL = N'SELECT * FROM Sales.SalesOrderHeader WHERE YEAR(OrderDate) = ' + CAST(@Year AS NVARCHAR);
EXEC sp_executesql @SQL;
```

**Best Practices:**
- Use `sp_executesql` with parameters to avoid SQL injection.
- Validate dynamic input.

---

## 27.7 Error Handling and TRY...CATCH

- Capture runtime errors and handle them gracefully.

**Example:**
```sql
BEGIN TRY
    INSERT INTO dbo.Orders (CustomerID, OrderDate, TotalDue)
    VALUES (1, GETDATE(), 100.0);
END TRY
BEGIN CATCH
    SELECT ERROR_NUMBER() AS ErrorNumber, ERROR_MESSAGE() AS ErrorMessage;
END CATCH;
```

---

## 27.8 Table-Valued Functions (TVFs)

- Encapsulate reusable queries.
- **Inline TVF:** Returns a single SELECT statement.
- **Multi-statement TVF:** Can have multiple statements and return a table variable.

**Example - Inline TVF:**
```sql
CREATE FUNCTION dbo.GetCustomerOrders(@CustomerID INT)
RETURNS TABLE
AS
RETURN (
    SELECT OrderID, OrderDate, TotalDue
    FROM dbo.Orders
    WHERE CustomerID = @CustomerID
);
```

**Usage:**
```sql
SELECT * FROM dbo.GetCustomerOrders(1);
```

---

## 27.9 Key Takeaways

- CTEs simplify complex and recursive queries.
- Window functions are powerful for analytics and ranking.
- APPLY operators enable per-row derived table calculations.
- PIVOT/UNPIVOT transform datasets for reporting.
- Advanced joins (anti/semi/self) improve query precision.
- Dynamic SQL allows flexible queries but requires caution.
- TRY...CATCH enhances robustness.
- Table-Valued Functions promote reusable, maintainable code.

---

**Conclusion:**
Mastering these advanced T-SQL patterns enables efficient, scalable, and maintainable query design, essential for real-world data engineering and analytical workloads.

