---
# 26. Performance Optimization and Query Tuning in MS SQL

**Objective:** Learn strategies and techniques to optimize SQL queries and ensure high-performance data operations.

---

## 26.1 Understanding Performance Bottlenecks and Execution Plans

Before tuning, identify where the query or system is slowing down:

- **CPU-bound:** High CPU usage due to complex calculations or inefficient query logic.
- **I/O-bound:** Slow disk access; often caused by table scans or missing indexes.
- **Memory-bound:** Insufficient memory for caching; causes frequent paging.
- **Blocking & Deadlocks:** Multiple queries waiting for resources.

**Execution Plans:**
- **Estimated Execution Plan:** SQL Server's optimizer plan before execution.
- **Actual Execution Plan:** Plan with runtime metrics; includes actual row counts, warnings.

**Example:**
```sql
SET STATISTICS XML ON;
SELECT * FROM dbo.Orders WHERE OrderDate >= '2024-01-01';
SET STATISTICS XML OFF;
```
- Look for table scans vs index seeks.
- Check warnings (missing statistics, spills, hash warnings).

**Tools:**
- `SET STATISTICS TIME ON` and `SET STATISTICS IO ON`
- Execution Plan Viewer in SSMS
- Dynamic Management Views (DMVs)
  - `sys.dm_exec_query_stats`
  - `sys.dm_exec_requests`
  - `sys.dm_db_index_physical_stats`

---

## 26.2 SARGable Queries

- Ensure predicates allow the use of indexes.
- Avoid functions on columns in WHERE/JOIN.

**Non-SARGable:**
```sql
WHERE YEAR(OrderDate) = 2024
```
**SARGable:**
```sql
WHERE OrderDate >= '2024-01-01' AND OrderDate < '2025-01-01'
```

---

## 26.3 Statistics and Index Maintenance

- **Statistics** help the optimizer estimate row counts.
- **Update Statistics:** `UPDATE STATISTICS dbo.Orders;`
- **Rebuild/Reorganize Indexes:** maintains page density and reduces fragmentation.

**Example:**
```sql
ALTER INDEX ALL ON dbo.Orders REBUILD;
```
- Rebuild locks table; reorganize is online but less thorough.

- Monitor fragmentation and usage:
```sql
SELECT index_id, avg_fragmentation_in_percent
FROM sys.dm_db_index_physical_stats(DB_ID(), OBJECT_ID('Sales.SalesOrderHeader'), NULL, NULL, 'LIMITED');
```

---

## 26.4 Query Refactoring Techniques

- Replace `NOT IN` with `NOT EXISTS` for better performance.
- Avoid correlated subqueries if possible; use joins or APPLY.
- Use temporary tables for intermediate results in complex queries.

**Example using APPLY for top-N per group:**
```sql
SELECT c.CustomerID, c.Name, o.TopOrderDate
FROM dbo.Customers c
OUTER APPLY (
    SELECT TOP 1 OrderDate AS TopOrderDate
    FROM dbo.Orders o
    WHERE o.CustomerID = c.CustomerID
    ORDER BY OrderDate DESC
) o;
```

---

## 26.5 Caching and Reuse

- Consider **query result caching** for frequently run analytical queries.
- Use **indexed views** for aggregations that are queried repeatedly.
- Cache intermediate calculations in temp tables when reused multiple times in a session.

---

## 26.6 Batch Operations and Set-Based Processing

- Avoid row-by-row (RBAR) operations; prefer set-based updates/inserts.
- Use `MERGE` for upsert scenarios instead of separate INSERT/UPDATE loops.

**Example MERGE:**
```sql
MERGE dbo.TargetTable AS tgt
USING dbo.SourceTable AS src
ON tgt.ID = src.ID
WHEN MATCHED THEN UPDATE SET tgt.Value = src.Value
WHEN NOT MATCHED THEN INSERT (ID, Value) VALUES (src.ID, src.Value);
```

- Replace cursors or loops with set-based operations.

---

## 26.7 Query Tuning Techniques and Index Optimization

- **Clustered Indexes:** Ensure primary key columns are properly clustered.
- **Non-Clustered Indexes:** Index columns used in WHERE, JOIN, ORDER BY, GROUP BY.
- **Filtered Indexes:** Useful for queries targeting a subset of rows.
- **Covering Indexes:** Include columns to avoid key lookups.

**Example:**
```sql
CREATE NONCLUSTERED INDEX idx_Sales_CustomerDate
ON Sales.SalesOrderHeader(CustomerID, OrderDate)
INCLUDE (TotalDue);
```

- Monitor fragmentation and index usage.

- **Query Hints:**
  - `OPTION (RECOMPILE)` for dynamic queries.
  - `FORCESEEK` to force index usage.

**Example:**
```sql
SELECT FirstName, LastName
FROM Sales.Customer
WHERE LastName LIKE 'A%'
OPTION (FORCESEEK);
```

---

## 26.8 Performance Monitoring Tools

- **DMVs (Dynamic Management Views):**
  - `sys.dm_exec_query_stats`
  - `sys.dm_exec_requests`
  - `sys.dm_exec_query_plan`
  - `sys.dm_db_index_usage_stats`
- **Query Store:** monitor historical performance trends, forced plans.
- **Extended Events:** capture waits, deadlocks, and query anomalies.

**Example:**
```sql
-- Identify top resource-consuming queries
SELECT TOP 10 qs.total_worker_time, qs.execution_count, qs.total_worker_time/qs.execution_count AS avg_cpu, st.text
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st
ORDER BY avg_cpu DESC;
```

---

## 26.9 Key Takeaways

- Performance tuning is iterative: measure → analyze → optimize.
- SARGable queries, proper indexing, and updated statistics are foundational.
- Always validate improvements using actual execution plans.
- Batch and set-based operations outperform loops for large datasets.
- Use temp tables, indexed views, and APPLY strategically for complex analytics.
- Monitor continuously using DMVs, Query Store, and Extended Events.

---

**Conclusion:**
Optimizing MS SQL performance requires a holistic approach: efficient query design, proper indexing, up-to-date statistics, batch processing, caching, and continuous monitoring to ensure reliable and scalable database performance.

